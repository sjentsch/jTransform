
# This file is automatically generated, you probably don't want to edit this

jtLong2WideOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            varID = NULL,
            varTme = NULL,
            varTgt = NULL,
            varExc = NULL,
            varOrd = "times",
            varAgg = "mean",
            varSep = "_",
            shwHlp = FALSE,
            btnCrt = FALSE,
            jxfLog = FALSE, ...) {

            super$initialize(
                package="jTransform",
                name="jtLong2Wide",
                requiresData=TRUE,
                ...)

            private$..varID <- jmvcore::OptionVariables$new(
                "varID",
                varID,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"),
                default=NULL)
            private$..varTme <- jmvcore::OptionVariables$new(
                "varTme",
                varTme,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"),
                default=NULL)
            private$..varTgt <- jmvcore::OptionVariables$new(
                "varTgt",
                varTgt,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"),
                default=NULL)
            private$..varExc <- jmvcore::OptionVariables$new(
                "varExc",
                varExc,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"),
                default=NULL)
            private$..varOrd <- jmvcore::OptionList$new(
                "varOrd",
                varOrd,
                options=list(
                    "times",
                    "vars"),
                default="times")
            private$..varAgg <- jmvcore::OptionList$new(
                "varAgg",
                varAgg,
                options=list(
                    "mean",
                    "first"),
                default="mean")
            private$..varSep <- jmvcore::OptionString$new(
                "varSep",
                varSep,
                default="_")
            private$..shwHlp <- jmvcore::OptionBool$new(
                "shwHlp",
                shwHlp,
                default=FALSE)
            private$..btnCrt <- jmvcore::OptionAction$new(
                "btnCrt",
                btnCrt,
                default=FALSE)
            private$..jxfLog <- jmvcore::OptionBool$new(
                "jxfLog",
                jxfLog,
                hidden=TRUE,
                default=FALSE)

            self$.addOption(private$..varID)
            self$.addOption(private$..varTme)
            self$.addOption(private$..varTgt)
            self$.addOption(private$..varExc)
            self$.addOption(private$..varOrd)
            self$.addOption(private$..varAgg)
            self$.addOption(private$..varSep)
            self$.addOption(private$..shwHlp)
            self$.addOption(private$..btnCrt)
            self$.addOption(private$..jxfLog)
        }),
    active = list(
        varID = function() private$..varID$value,
        varTme = function() private$..varTme$value,
        varTgt = function() private$..varTgt$value,
        varExc = function() private$..varExc$value,
        varOrd = function() private$..varOrd$value,
        varAgg = function() private$..varAgg$value,
        varSep = function() private$..varSep$value,
        shwHlp = function() private$..shwHlp$value,
        btnCrt = function() private$..btnCrt$value,
        jxfLog = function() private$..jxfLog$value),
    private = list(
        ..varID = NA,
        ..varTme = NA,
        ..varTgt = NA,
        ..varExc = NA,
        ..varOrd = NA,
        ..varAgg = NA,
        ..varSep = NA,
        ..shwHlp = NA,
        ..btnCrt = NA,
        ..jxfLog = NA)
)

jtLong2WideResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideResults",
    inherit = jmvcore::Group,
    active = list(
        fmtHTM = function() private$.items[["fmtHTM"]],
        genInf = function() private$.items[["genInf"]],
        dtaInf = function() private$.items[["dtaInf"]],
        pvwDta = function() private$.items[["pvwDta"]],
        pvwLvl = function() private$.items[["pvwLvl"]],
        addInf = function() private$.items[["addInf"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Long to Wide")
            self$add(jmvcore::Html$new(
                options=options,
                name="fmtHTM",
                clearWith=list(),
                content="<style> #fmtHTM { display: none; } table { width: 100%; border-collapse: collapse; } th { background-color: #3e6da9; color: white; text-align: left; } tbody > td { border: 1px solid #ddd; padding: 8px; } tbody > tr:nth-child(even) { background-color: #d6eaf8; } tbody > tr:nth-child(odd) { background-color: #ffffff; } tbody > tr:hover { background-color: #aed6f1; } </style>\n"))
            self$add(jmvcore::Html$new(
                options=options,
                name="genInf",
                visible="(shwHlp)",
                clearWith=list(),
                content="Please assign the variables that identify participant (or another measurement unit; e.g., a number or an ID) to \"Variables that identify the same unit\", and those that are unique to an unit but not an identifier (e.g., gender, age group) to \"Variables NOT to be Transformed\". \"Variables That Differentiate Within a Unit\" typically contain different (e.g., experimental) conditions, and \"Variables To Be Transformed\" are the actual measurements (e.g., responses, reaction times, etc.).</p> <p>For an example about a typical long-to-wide-transformation, see the last paragraph in \"Details\" underneath the output tables.\n"))
            self$add(jmvcore::Html$new(
                options=options,
                name="dtaInf",
                clearWith=list(
                    "varID",
                    "varTme",
                    "varTgt",
                    "varExc",
                    "varOrd",
                    "varAgg",
                    "varSep",
                    "btnCrt"),
                content=""))
            self$add(jmvcore::Table$new(
                options=options,
                name="pvwDta",
                title="Data Preview",
                refs=list(
                    "jTransform",
                    "jmvReadWrite"),
                clearWith=list(
                    "varID",
                    "varTme",
                    "varTgt",
                    "varExc",
                    "varOrd",
                    "varAgg",
                    "varSep"),
                rows=1,
                columns=list(
                    list(
                        `name`="fstCol", 
                        `title`=""))))
            self$add(jmvcore::Table$new(
                options=options,
                name="pvwLvl",
                title="Repeated Measures Levels",
                clearWith=list(
                    "varID",
                    "varTme",
                    "varTgt",
                    "varExc",
                    "varOrd",
                    "varAgg",
                    "varSep"),
                columns=list(
                    list(
                        `name`="fstCol", 
                        `title`=""))))
            self$add(jmvcore::Html$new(
                options=options,
                name="addInf",
                visible="(shwHlp)",
                clearWith=list(),
                content="<h2>Details</h2> <p>\"Variables that identify the same unit\" is an ID variable (e.g., a participant code). This code needs to be unique (i.e., there can't be two participants, or other units, with the same ID).</p> <p> \"Variables that differentiate within an unit\" are the so-called time-varying variables, i.e., variables that are originally are arranged in rows and whose steps shall be transformed into columns (a new column created for the each combination of a target variable, e.g., reaction time [RT], with each experimental condition [cond\u2026] leading RT_cond1, RT_cond2, \u2026). There can be several time-varying variables (e.g., several facors in an experiment, each represented by a different column in the input data set).</p> <p>\"Variables to be transformed\" are the so-called target variables, i.e., variables that exist as one column in the input data set and are going to be transformed / combined with each step of a time-varying variable resulting in as many columns as there are steps (e.g., would reaction time be one column in the input data set, resulting in as many columns as there are different combinations of time-varying variables in the output data set; if there are 3 steps on the first time-varying variable and 4 steps on the second, this would result in 12 columns in the output data set).</p> <p>\"Variables NOT to be transformed\" are variables that \"characterize\" a participant (or another unit), often also called between-subjects variables, e.g., age or sex. However, they are not unique (and thus no ID variables; there may be several participant with the same age or sex).</p> <p>\"Variable organization in the output\" determines how the variables are to be arranged in the output data set. This is only relevant if there is more than one target variable (e.g., if you want to transform both correct responses and reaction times). \"Variables are adjacent\" keeps the target variables in adjacent columns (for the example above, correct responses and reaction time would be adjacent, and on the higher levels, the steps of the time-varying variable / conditions would vary). \"Time steps are adjacent\" would produce a block where all steps of the time-varying variable / conditions for the first target variable are adjacent, followed by a block of all conditions of the second variable and so on.</p> <p>\"How to accumulate?\" determines how different rows may be accumulated. The setting does not apply if there is only one occurence / row for each possible combination of conditions. Let's assume that you ran an experiment with two factors: the experimental condition and which repetition of that condition an entry represents. For evaluation, you want to drop the repetition (you thus only assign the variable representing the condition to \"Variables that differentiate within an unit\". The setting determines if the mean of these occurrences shall be calculated (\"Calculate mean\") or if all occurences after the first should be dropped (\"First occurence\").</p> <p>\"Separator\" defines which character(s) should be placed between the target variable and the steps of the time-varying variable / conditions when assembling the variable names (e.g., VAR_COND).</p> <p></p> <p>The principle of the transformation from long to wide can perhaps easiest be understood by looking at example4jtLong2Wide from the Data Library of this module. It contains results from a Stroop experiment (in long format) with seven variables: ID (identifies the participant), sex (of the participant), cond (of the Stroop experiment; congruent, neutral, and incongruent), colour (in which the target word was written), rep (which repetition of a particular cond-colour-combination this entry is), rspCrr (whether the participant named the correct colour), and rspTme (the reaction time for that response). These variables have to be assigned to the following fields: ID to \"Variables that identify the same unit\" (it is an unique identifier of each participant); cond, colour and rep to \"Variables that differentiate within an unit\" (representing all possible combinations of experimental conditions); rspCrr and rspTme to \"Variables to be transformed\" (these measurements are repeated for each combination of conditions, and in a result we want a column each for all possible combinations of those variables and the experimental conditions, i.e., within-subject variables); and finally sex to \"Variables NOT to be transformed\" (since sex is a between-subjects variable that doesn't change between experimental condition, we thus only need one column in the output; however, it is not unique and thus not suited as ID variable).</p>\n"))}))

jtLong2WideBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jTransform",
                name = "jtLong2Wide",
                version = c(1,0,0),
                options = options,
                results = jtLong2WideResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = TRUE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Long to Wide
#'
#' Transform a Data Set From Long to Wide
#'
#' @examples
#' \donttest{
#' # the function is a wrapper for jmvReadWrite::long2wide_omv
#' # please use that function when in R (or in Rj)
#' # for more information: https://sjentsch.github.io/jmvReadWrite
#'}
#' @param data .
#' @param varID .
#' @param varTme .
#' @param varTgt .
#' @param varExc .
#' @param varOrd .
#' @param varAgg .
#' @param varSep .
#' @param shwHlp .
#' @param btnCrt .
#' @param jxfLog .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$fmtHTM} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$genInf} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$dtaInf} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$pvwDta} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$pvwLvl} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$addInf} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$pvwDta$asDF}
#'
#' \code{as.data.frame(results$pvwDta)}
#'
#' @export
jtLong2Wide <- function(
    data,
    varID = NULL,
    varTme = NULL,
    varTgt = NULL,
    varExc = NULL,
    varOrd = "times",
    varAgg = "mean",
    varSep = "_",
    shwHlp = FALSE,
    btnCrt = FALSE,
    jxfLog = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("jtLong2Wide requires jmvcore to be installed (restart may be required)")

    if ( ! missing(varID)) varID <- jmvcore::resolveQuo(jmvcore::enquo(varID))
    if ( ! missing(varTme)) varTme <- jmvcore::resolveQuo(jmvcore::enquo(varTme))
    if ( ! missing(varTgt)) varTgt <- jmvcore::resolveQuo(jmvcore::enquo(varTgt))
    if ( ! missing(varExc)) varExc <- jmvcore::resolveQuo(jmvcore::enquo(varExc))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(varID), varID, NULL),
            `if`( ! missing(varTme), varTme, NULL),
            `if`( ! missing(varTgt), varTgt, NULL),
            `if`( ! missing(varExc), varExc, NULL))


    options <- jtLong2WideOptions$new(
        varID = varID,
        varTme = varTme,
        varTgt = varTgt,
        varExc = varExc,
        varOrd = varOrd,
        varAgg = varAgg,
        varSep = varSep,
        shwHlp = shwHlp,
        btnCrt = btnCrt,
        jxfLog = jxfLog)

    analysis <- jtLong2WideClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

